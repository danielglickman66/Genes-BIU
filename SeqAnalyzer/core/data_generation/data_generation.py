"""
FOR RANDOM SEQUENCES:
Generates files listing sequences generated by some model(e.g random characters).
each line in the file is a seperate sequence.

2 types of files are created:
file.txt - original sequences generated by the model(random for now)
noisy_file.txt - the sequences after some noise sub_sequence was inserted to them at random.

file format:
- each line is a seperate sequence.item/letters of the sequence are se[erated by commas.
- the noisy file start with a header:
   header format: #[sequence] noise_probability //other comments
"""


import numpy as np
import sys
import random
import string
import os

alphabet = ['A','B','C','D'];  



"""writes the list of sequences to a file.
each sequence is writen to a seperate file and items(letters) in a sequence are seperated with commas.
adds a header as the first line of the file if given."""
def write_sequences_to_file(list_of_sequences,filename,header=None):
    to_write = ""
    
    #append all the list to one big string for writing it all at once later.
    for sequence in list_of_sequences:
        to_write += clean(str(sequence)[1:-1])+'\n'  #add new sequence [A,B,C] as "A B C" 

    write_to_file(filename,to_write,header)


def write_to_file(filename,to_write,header=None):

    
    if header != None:
        to_write = header + '\n' + to_write


    open(filename, "wb").write(to_write)


#helper to create the files and sequences.
#if noisy_like_original is false, will create 2 different set of random sequences , but one has noise inserted to it.
def generate_sequences(noise,probability,filename,num_sequences,alphabet = ['A','B','C','D'],noisy_like_original =True):
    def gen_seq():
        all_sequences = []
        for i in range(num_sequences):
            sequence_length = random.randint(300,600)
            all_sequences.append(generate_random_sequence(alphabet,sequence_length))
        return all_sequences

    all_sequences = gen_seq()
    write_sequences_to_file(all_sequences,filename)

    if not noisy_like_original:
        all_sequences = gen_seq()

    for i in range(num_sequences):
        all_sequences[i] = insert_noise_to_sequence(all_sequences[i],noise,probability)

    header = "#" + str(noise)[1:-1] + ' ' + str(probability) + ' //number of noise sequence inserted is noraml distributed with mean=length(sequence)*probability'
    write_sequences_to_file(all_sequences,'noisy_'+filename,header)


""" gets a sub-sequence as a list of noises and inserts items(noise) from the noises 
to the original sequence  at random indexs.
noise will be inserted at each index with the given probability,so in a list of length n,
n*probability noise items will be inserted and function will return list of size n+n*probability*length(noise).
see (1) for insert_noise_in_other_noise explanition."""
def insert_noise_to_sequence(sequence,noise, probability,  insert_noise_in_other_noise = False):
    
    mean = int(len(sequence)*probability)
    #n is number of times to insert the noise sub-seq.for now n is taken from normal disturbiution.
    n = int(np.random.normal(loc=mean, scale=5.0)) #should prob change this to get any disturbiution function.
    
    #create random indexes to insert noise.
    random_numbers = [random.randint(0,len(sequence)+1) for i in range(n)]
    random_numbers.sort()

    """ (1) keep track of how much noise we added.
    by doing so,we make sure we will not insert a noise sequence in between another earlier noise sequence.
    (e.g we had AB and inserted noise to make AXYZB.this algorithm will NOT break the first XYZ like so:AXYXYZZB)"""
    if not insert_noise_in_other_noise:
        noise_offset = 1
    else:
         noise_offset = 0 #ignore offset by keeping it zero.

    offset_from_noise = 0
    
    for number in random_numbers:
        #add the noise list at each random index.
        #sequence[number+offset_from_noise:number+offset_from_noise] = noise
        sequence.insert(number + offset_from_noise,noise) 
        #sequence[0:number] + [noise] + sequence[number:]
        offset_from_noise += noise_offset


    return sequence

def clean(txt , trim_newlines = False):
        #remove punctuation
        for char in string.punctuation + ' ':
            txt = txt.replace(char, '')
        if trim_newlines:
            txt = txt.replace('\n', '')
            txt = txt.replace('\r', '')

        return txt

def generate_random_sequence(alphabet,sequence_length):
     seq = []
     #takes a random item from the alphabet each iteration and append to the sequence.
     for i in range(sequence_length):
        seq.append(random.choice(alphabet))

     return seq

#how many time the sub-seq is shown in the full sequence.
def count_frequency(sequence,sub_sequence):
    length = len(sub_sequence)
    count = 0
    for i in range(len(sequence) - length):
        if sequence[i:i+length] == sub_sequence:
            count +=1
    return count

                                                    #if true, trim spaces from text.
def noisy_from_existing_file(filename,noises, no_space = True):

    new_filename = 'noisy_' + filename
    text = open(filename).read()
    text = text.lower()

    #header = "#" + str(noise)[1:-1] + ' ' + str(prob) + ' //number of noise sequence inserted is noraml distributed with mean=length(sequence)*probability'
    noisy_text = text.split(' ')
    for prob,noise in noises:
        noisy_text = insert_noise_to_sequence(noisy_text,noise,prob)
    if no_space:
               
        write_to_file(new_filename,clean(''.join(noisy_text)))
    
    else:    
        write_to_file(new_filename,' '.join(noisy_text))



#creates a new file from original.
#the orignal files is cut into strings of length n_col and each line is such string.
def format_file(orignal , new ,  n_col , n_lines=0 ):
    text = open(orignal).read()
    text = text.lower()
    text = clean(text, True)

    with open(new , 'wb') as f:
        s = ''
        for i in range(0,len(text) , n_col):
            s += text[i:i+n_col] +'\n'
        f.write(s)



"""
input: this_is_a_string
output: this is a string
"""
def to_regular_string(s):
    s = s.split('_')
    return ' '.join(s)   
        

if len(sys.argv) > 1:
    # format original new n_col
    if 'format' in sys.argv:
        sys.argv.remove('format')
        filename = sys.argv[1]
        if len(sys.argv) > 3:
            new = sys.argv[2]
            sys.argv.remove(new)
        else : new = 'format_'+filename
        n_col = int(sys.argv[2])

        if os.path.isdir(filename):
            for f in os.listdir(filename):
                format_file(filename+'/'+f ,'format_'+f , n_col )
        else :
            format_file(filename , new , n_col)

    elif '-RANDOM-SEQ' in sys.argv:
        sys.argv.remove('-RANDOM-SEQ')
        filename = sys.argv[1]
        prob = float(sys.argv[2])
        noise= 'CAC'
        num_sequences = int(sys.argv[-1])
        generate_sequences(noise,prob, filename, num_sequences,alphabet,False)

    else:
        no_space = False
        if '-no_space' in sys.argv:
            sys.argv.remove('-no_space')
            no_space = True
        filename = sys.argv[1]
        noises = []
        i = 2
        while i in range(len(sys.argv)): 
            prob = float(sys.argv[i])
            noise = to_regular_string(sys.argv[i+1])
            noises.append((prob,noise))
            i += 2

        noisy_from_existing_file(filename,noises,no_space)


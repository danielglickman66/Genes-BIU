"""
FOR RANDOM SEQUENCES:
Generates files listing sequences generated by some model(e.g random characters).
each line in the file is a seperate sequence.

2 types of files are created:
file.txt - original sequences generated by the model(random for now)
noisy_file.txt - the sequences after some noise sub_sequence was inserted to them at random.

file format:
- each line is a seperate sequence.item/letters of the sequence are se[erated by commas.
- the noisy file start with a header:
   header format: #[sequence] noise_probability //other comments
"""


import numpy as np
import sys
import random
import string


alphabet = ['A','B','C','D'];  



"""writes the list of sequences to a file.
each sequence is writen to a seperate file and items(letters) in a sequence are seperated with commas.
adds a header as the first line of the file if given."""
def write_sequences_to_file(list_of_sequences,filename,header=None):
    to_write = ""
    
    #append all the list to one big string for writing it all at once later.
    for sequence in list_of_sequences:
        to_write += clean(str(sequence)[1:-1]) + '\n' #add new sequence [A,B,C] as "A B C" 

    write_to_file(filename,to_write,header)


def write_to_file(filename,to_write,header=None):

    
    if header != None:
        to_write = header + '\n' + to_write


    open(filename, "wb").write(to_write)


#helper to create the files and sequences.
def generate_sequences(noise,probability,filename,num_sequences,alphabet = ['A','B','C','D']):
    all_sequences = []
    for i in range(num_sequences):
        sequence_length = random.randint(300,600)
        all_sequences.append(generate_random_sequence(alphabet,sequence_length))

    write_sequences_to_file(all_sequences,filename)

    for i in range(num_sequences):
        all_sequences[i] = insert_noise_to_sequence(all_sequences[i],noise,probability)

    header = "#" + str(noise)[1:-1] + ' ' + str(probability) + ' //number of noise sequence inserted is noraml distributed with mean=length(sequence)*probability'
    write_sequences_to_file(all_sequences,'noisy_'+filename,header)


""" gets a sub-sequence as a list of noises and inserts items(noise) from the noises 
to the original sequence  at random indexs.
noise will be inserted at each index with the given probability,so in a list of length n,
n*probability noise items will be inserted and function will return list of size n+n*probability*length(noise).
see (1) for insert_noise_in_other_noise explanition."""
def insert_noise_to_sequence(sequence,noise, probability,  insert_noise_in_other_noise = False):
    
    mean = int(len(sequence)*probability)
    #n is number of times to insert the noise sub-seq.for now n is taken from normal disturbiution.
    n = int(np.random.normal(loc=mean, scale=5.0)) #should prob change this to get any disturbiution function.
    
    #create random indexes to insert noise.
    random_numbers = [random.randint(0,len(sequence)) for i in range(n)]
    random_numbers.sort()

    """ (1) keep track of how much noise we added.
    by doing so,we make sure we will not insert a noise sequence in between another earlier noise sequence.
    (e.g we had AB and inserted noise to make AXYZB.this algorithm will NOT break the first XYZ like so:AXYXYZZB)"""
    if not insert_noise_in_other_noise:
        noise_offset = len(noise)
    else:
         noise_offset = 0 #ignore offset by keeping it zero.

    offset_from_noise = 0
    
    for number in random_numbers:
        #add the noise list at each random index.
        sequence[number+offset_from_noise:number+offset_from_noise] = noise
        offset_from_noise += noise_offset


    return sequence

def clean(txt):
        #remove punctuation
        for char in string.punctuation + ' ':
            txt = txt.replace(char, '')
        return txt

def generate_random_sequence(alphabet,sequence_length):
     seq = []
     #takes a random item from the alphabet each iteration and append to the sequence.
     for i in range(sequence_length):
        seq.append(random.choice(alphabet))

     return seq

#how many time the sub-seq is shown in the full sequence.
def count_frequency(sequence,sub_sequence):
    length = len(sub_sequence)
    count = 0
    for i in range(len(sequence) - length):
        if sequence[i:i+length] == sub_sequence:
            count +=1
    return count

                                                    #if true, trim spaces from text.
def noisy_from_existing_file(filename,prob, noise, no_space = True):

    new_filename = 'noisy_' + filename
    text = open(filename).read()
    text = text.lower()

    header = "#" + str(noise)[1:-1] + ' ' + str(prob) + ' //number of noise sequence inserted is noraml distributed with mean=length(sequence)*probability'
    text = text.split(' ')
    noisy_text = insert_noise_to_sequence(text,noise,prob)
    if no_space:
               
        write_to_file(new_filename,clean(''.join(noisy_text)),header)
    
    else:    
        write_to_file(new_filename,' '.join(noisy_text),header)

   
        


filename = sys.argv[1]
prob = float(sys.argv[2])


if '-RANDOM-SEQ' in sys.argv:
    sys.argv.remove('-RANDOM-SEQ')
    noise=['A','B','C']
    num_sequences = int(sys.argv[3])
    generate_sequences(noise,prob, filename, num_sequences,alphabet)

else:
    no_space = False
    if '-no_space' in sys.argv:
        sys.argv.remove('-no_space')
        no_space = True

    noise = sys.argv[3:]

    noisy_from_existing_file(filename,prob,noise,no_space)

